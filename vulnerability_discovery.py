# vulnerability_discovery.py
from flask import Blueprint, jsonify, request
import requests
import json
import base64
from datetime import datetime, timedelta
import urllib3
import logging
from typing import Dict, List, Any, Optional
import re
from config import Config

# Disable SSL warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Create blueprint
vuln_bp = Blueprint('vulnerability_discovery', __name__)

logger = logging.getLogger(__name__)

class WazuhVulnerabilityClient:
    def __init__(self, base_url = None, 
                 username = None, 
                 password = None,
                 verify_ssl: bool = False):
        self.base_url = f"https://{Config.WAZUH_HOST}:9200"
        self.username = Config.WAZUH_USERNAME
        self.password = Config.WAZUH_PASSWORD
        self.verify_ssl = Config.WAZUH_VERIFY_SSL
        self.logger = logging.getLogger(__name__)
        
    def _get_auth_header(self) -> str:
        credentials = f"{self.username}:{self.password}"
        encoded_credentials = base64.b64encode(credentials.encode()).decode()
        return f"Basic {encoded_credentials}"
    
    def _make_request(self, endpoint: str, query: Dict) -> Dict:
        """Make API request to Wazuh Elasticsearch"""
        url = f"{self.base_url}/{endpoint}"
        
        headers = {
            'Content-Type': 'application/json',
            'Authorization': self._get_auth_header()
        }
        
        try:
            response = requests.post(
                url,
                headers=headers,
                json=query,
                verify=self.verify_ssl,
                timeout=30
            )
            response.raise_for_status()
            return response.json()
        except requests.exceptions.RequestException as e:
            self.logger.error(f"Vulnerability API request failed: {e}")
            return {"error": str(e), "hits": {"hits": [], "total": {"value": 0}}}
    
    def get_vulnerabilities(self, size: int = 1000, from_index: int = 0, filters: Dict = None) -> Dict:
        """Get only valid CVE vulnerabilities from Wazuh states"""
        # Base query to get only documents with valid CVE IDs
        query = {
            "query": {
                "bool": {
                    "must": [
                        {
                            "exists": {
                                "field": "vulnerability.id"
                            }
                        },
                        {
                            "wildcard": {
                                "vulnerability.id": "CVE-*"
                            }
                        }
                    ]
                }
            },
            "sort": [{"vulnerability.detected_at": {"order": "desc"}}],
            "size": size,
            "from": from_index
        }
        
        # Add additional filters if provided
        if filters:
            bool_query = query["query"]["bool"]
            
            if filters.get('severity'):
                bool_query["must"].append({
                    "term": {"vulnerability.severity.keyword": filters['severity']}
                })
            
            if filters.get('agent_id'):
                bool_query["must"].append({
                    "term": {"agent.id": filters['agent_id']}
                })
            
            if filters.get('search'):
                bool_query["must"].append({
                    "multi_match": {
                        "query": filters['search'],
                        "fields": [
                            "vulnerability.id",
                            "vulnerability.description",
                            "package.name"
                        ]
                    }
                })
        
        print(f"🔍 [Vulnerability Query] Executing CVE-only query with filters: {filters}")
        
        return self._make_request("wazuh-states-vulnerabilities-*/_search", query)
    
    def get_vulnerability_stats(self) -> Dict:
        """Get vulnerability statistics for dashboard - only valid CVEs"""
        query = {
            "size": 0,
            "query": {
                "bool": {
                    "must": [
                        {
                            "exists": {
                                "field": "vulnerability.id"
                            }
                        },
                        {
                            "wildcard": {
                                "vulnerability.id": "CVE-*"
                            }
                        }
                    ]
                }
            },
            "aggs": {
                "severity_breakdown": {
                    "terms": {
                        "field": "vulnerability.severity.keyword",
                        "size": 10
                    }
                },
                "unique_agents": {
                    "cardinality": {
                        "field": "agent.name.keyword"
                    }
                },
                "top_cves": {
                    "terms": {
                        "field": "vulnerability.id.keyword",
                        "size": 10
                    }
                },
                "top_packages": {
                    "terms": {
                        "field": "package.name.keyword",
                        "size": 10
                    }
                }
            }
        }
        
        return self._make_request("wazuh-states-vulnerabilities-*/_search", query)
    
    def get_all_vulnerabilities_for_stats(self, size: int = 10000) -> Dict:
        """Get all vulnerabilities for accurate client-side statistics"""
        query = {
            "query": {
                "bool": {
                    "must": [
                        {
                            "exists": {
                                "field": "vulnerability.id"
                            }
                        },
                        {
                            "wildcard": {
                                "vulnerability.id": "CVE-*"
                            }
                        }
                    ]
                }
            },
            "size": size,
            "sort": [{"vulnerability.detected_at": {"order": "desc"}}]
        }
        
        return self._make_request("wazuh-states-vulnerabilities-*/_search", query)

class VulnerabilityDataProcessor:
    """Process vulnerability data for the dashboard"""
    
    @staticmethod
    def is_valid_cve(cve_id: str) -> bool:
        """Check if the CVE ID is valid"""
        if not cve_id:
            return False
        
        # CVE pattern: CVE-YYYY-NNNN...
        cve_pattern = r'^CVE-\d{4}-\d+'
        return bool(re.match(cve_pattern, cve_id))
    
    @staticmethod
    def process_vulnerabilities(raw_data: Dict) -> Dict[str, Any]:
        """Process raw vulnerability data for dashboard - only valid CVEs"""
        if not raw_data or 'hits' not in raw_data:
            print("❌ [Vulnerability Process] No raw data or hits missing")
            return VulnerabilityDataProcessor.get_empty_data()
        
        hits = raw_data['hits']['hits']
        total_hits = raw_data['hits']['total']['value']
        
        print(f"🔍 [Vulnerability Process] Processing {total_hits} total hits, {len(hits)} returned")
        
        vulnerabilities = []
        severity_counts = {
            'Critical': 0,
            'High': 0, 
            'Medium': 0,
            'Low': 0
        }
        agent_vulnerabilities = {}
        cve_counts = {}
        package_counts = {}
        
        valid_cve_count = 0
        invalid_cve_count = 0
        
        for hit in hits:
            vuln_data = VulnerabilityDataProcessor.process_single_vulnerability(hit)
            
            # Only include valid CVE entries
            if vuln_data and VulnerabilityDataProcessor.is_valid_cve(vuln_data['cve_id']):
                vulnerabilities.append(vuln_data)
                valid_cve_count += 1
                
                # Update counts - use the actual severity from the data
                severity = vuln_data['severity']
                if severity in severity_counts:
                    severity_counts[severity] += 1
                else:
                    # If severity is not in our standard list, categorize it
                    normalized_severity = VulnerabilityDataProcessor.normalize_severity(severity)
                    if normalized_severity in severity_counts:
                        severity_counts[normalized_severity] += 1
                    else:
                        print(f"⚠️ [Severity] Unknown severity: {severity}")
                
                # Agent counts
                agent_name = vuln_data['agent_name']
                agent_vulnerabilities[agent_name] = agent_vulnerabilities.get(agent_name, 0) + 1
                
                # CVE counts
                cve_id = vuln_data['cve_id']
                cve_counts[cve_id] = cve_counts.get(cve_id, 0) + 1
                
                # Package counts
                package_name = vuln_data['package_name']
                if package_name:
                    package_counts[package_name] = package_counts.get(package_name, 0) + 1
            else:
                invalid_cve_count += 1
                if vuln_data and vuln_data['cve_id']:
                    print(f"⚠️ [CVE Filter] Skipping invalid CVE: {vuln_data['cve_id']}")
        
        print(f"✅ [Vulnerability Process] Found {valid_cve_count} valid CVEs, filtered {invalid_cve_count} invalid entries")
        print(f"📊 [Severity Breakdown] Critical: {severity_counts['Critical']}, High: {severity_counts['High']}, Medium: {severity_counts['Medium']}, Low: {severity_counts['Low']}")
        
        # Get critical and high vulnerabilities
        critical_high_vulns = [
            vuln for vuln in vulnerabilities 
            if vuln['severity'] in ['Critical', 'High']
        ]
        
        return {
            'summary': {
                'total_vulnerabilities': valid_cve_count,
                'critical_vulnerabilities': severity_counts['Critical'],
                'high_vulnerabilities': severity_counts['High'],
                'affected_agents': len(agent_vulnerabilities),
                'risk_score': VulnerabilityDataProcessor.calculate_risk_score(severity_counts),
                'last_scan': VulnerabilityDataProcessor.get_last_scan_time(vulnerabilities)
            },
            'charts': {
                'severity_distribution': severity_counts,
                'top_cves': dict(sorted(cve_counts.items(), key=lambda x: x[1], reverse=True)[:10]),
                'affected_agents': dict(sorted(agent_vulnerabilities.items(), key=lambda x: x[1], reverse=True)[:10]),
                'vulnerable_packages': dict(sorted(package_counts.items(), key=lambda x: x[1], reverse=True)[:10])
            },
            'critical_high_vulnerabilities': critical_high_vulns[:20],
            'vulnerabilities': vulnerabilities,
            'last_updated': datetime.now().isoformat(),
            'debug_info': {
                'total_hits': total_hits,
                'valid_cves': valid_cve_count,
                'invalid_cves': invalid_cve_count,
                'severity_breakdown': severity_counts
            }
        }
    
    @staticmethod
    def normalize_severity(severity: str) -> str:
        """Normalize severity to standard categories"""
        if not severity:
            return 'Unknown'
        
        severity_lower = severity.lower()
        
        if 'critical' in severity_lower:
            return 'Critical'
        elif 'high' in severity_lower:
            return 'High'
        elif 'medium' in severity_lower or 'moderate' in severity_lower:
            return 'Medium'
        elif 'low' in severity_lower:
            return 'Low'
        else:
            return 'Unknown'
    
    @staticmethod
    def process_single_vulnerability(hit: Dict) -> Dict[str, Any]:
        """Process a single vulnerability entry"""
        try:
            source = hit.get('_source', {})
            vulnerability = source.get('vulnerability', {})
            agent = source.get('agent', {})
            package = source.get('package', {})
            host = source.get('host', {})
            
            # Extract CVE ID - using 'id' field from vulnerability
            cve_id = vulnerability.get('id', '')
            
            # Skip if no CVE ID
            if not cve_id:
                return None
            
            # Get and normalize severity
            raw_severity = vulnerability.get('severity', 'Unknown')
            normalized_severity = VulnerabilityDataProcessor.normalize_severity(raw_severity)
            
            return {
                'id': hit.get('_id', ''),
                'timestamp': source.get('@timestamp', ''),
                'cve_id': cve_id,
                'title': VulnerabilityDataProcessor.extract_title(vulnerability.get('description', '')),
                'description': vulnerability.get('description', ''),
                'severity': normalized_severity,
                'raw_severity': raw_severity,  # Keep original for reference
                'cvss_score': vulnerability.get('score', {}).get('base', 0),
                'cvss_version': vulnerability.get('score', {}).get('version', ''),
                'package_name': package.get('name', ''),
                'package_version': package.get('version', ''),
                'package_architecture': package.get('architecture', ''),
                'package_path': package.get('path', ''),
                'agent_id': agent.get('id', ''),
                'agent_name': agent.get('name', 'Unknown Agent'),
                'agent_ip': agent.get('ip', ''),
                'agent_version': agent.get('version', ''),
                'detected_at': vulnerability.get('detected_at', ''),
                'published_at': vulnerability.get('published_at', ''),
                'status': 'Active' if not vulnerability.get('under_evaluation', True) else 'Under Evaluation',
                'reference': vulnerability.get('reference', ''),
                'category': vulnerability.get('category', ''),
                'scanner_vendor': vulnerability.get('scanner', {}).get('vendor', ''),
                'scanner_source': vulnerability.get('scanner', {}).get('source', ''),
                'os_name': host.get('os', {}).get('name', ''),
                'os_version': host.get('os', {}).get('version', ''),
                'raw_data': source
            }
        except Exception as e:
            print(f"❌ Error processing vulnerability: {e}")
            return None
    
    @staticmethod
    def extract_title(description: str) -> str:
        """Extract a concise title from the description"""
        if not description:
            return 'No title available'
        
        # Take first sentence or first 100 characters
        first_sentence = description.split('.')[0]
        if len(first_sentence) > 100:
            return first_sentence[:100] + '...'
        return first_sentence
    
    @staticmethod
    def calculate_risk_score(severity_counts: Dict) -> float:
        """Calculate overall risk score based on severity distribution"""
        total = sum(severity_counts.values())
        if total == 0:
            return 0.0
        
        # Weighted score: Critical=1.0, High=0.7, Medium=0.4, Low=0.1
        weighted_score = (
            severity_counts['Critical'] * 1.0 +
            severity_counts['High'] * 0.7 +
            severity_counts['Medium'] * 0.4 +
            severity_counts['Low'] * 0.1
        )
        
        max_possible_score = total * 1.0  # If all were critical
        risk_percentage = (weighted_score / max_possible_score) * 100
        
        return round(risk_percentage, 1)
    
    @staticmethod
    def get_last_scan_time(vulnerabilities: List[Dict]) -> str:
        """Get the most recent detection time"""
        if not vulnerabilities:
            return "Never"
        
        latest_detection = max(
            [vuln['detected_at'] for vuln in vulnerabilities if vuln['detected_at']],
            default=None
        )
        
        if not latest_detection:
            return "Unknown"
        
        try:
            # Handle different timestamp formats
            if 'T' in latest_detection:
                detection_time = datetime.fromisoformat(latest_detection.replace('Z', '+00:00'))
            else:
                detection_time = datetime.fromisoformat(latest_detection)
                
            now = datetime.now().replace(tzinfo=detection_time.tzinfo)
            diff = now - detection_time
            
            if diff.days > 0:
                return f"{diff.days}d ago"
            elif diff.seconds >= 3600:
                return f"{diff.seconds // 3600}h ago"
            else:
                return f"{diff.seconds // 60}m ago"
        except Exception as e:
            print(f"❌ Error calculating last scan time: {e}")
            return "Unknown"
    
    @staticmethod
    def get_empty_data():
        return {
            'summary': {
                'total_vulnerabilities': 0,
                'critical_vulnerabilities': 0,
                'high_vulnerabilities': 0,
                'affected_agents': 0,
                'risk_score': 0.0,
                'last_scan': 'Never'
            },
            'charts': {
                'severity_distribution': {'Critical': 0, 'High': 0, 'Medium': 0, 'Low': 0},
                'top_cves': {},
                'affected_agents': {},
                'vulnerable_packages': {}
            },
            'critical_high_vulnerabilities': [],
            'vulnerabilities': [],
            'last_updated': datetime.now().isoformat(),
            'debug_info': {
                'total_hits': 0,
                'valid_cves': 0,
                'invalid_cves': 0,
                'severity_breakdown': {'Critical': 0, 'High': 0, 'Medium': 0, 'Low': 0}
            }
        }

# Initialize clients
vuln_client = WazuhVulnerabilityClient()
vuln_processor = VulnerabilityDataProcessor()

# API Routes
@vuln_bp.route('/api/vulnerabilities')
def get_vulnerabilities():
    """Get vulnerabilities with filtering and pagination - only valid CVEs"""
    try:
        print("🔍 [Vulnerability API] /api/vulnerabilities endpoint called")
        
        # Get query parameters
        page = int(request.args.get('page', 1))
        per_page = int(request.args.get('per_page', 50))
        severity = request.args.get('severity', '')
        agent_id = request.args.get('agent_id', '')
        search = request.args.get('search', '')
        
        print(f"🔍 [Vulnerability API] Parameters - page: {page}, severity: {severity}, agent_id: {agent_id}, search: {search}")

        # Build filters
        filters = {}
        if severity:
            filters['severity'] = severity
        if agent_id:
            filters['agent_id'] = agent_id
        if search:
            filters['search'] = search

        # Calculate pagination
        from_index = (page - 1) * per_page
        
        # Get vulnerability data - only valid CVEs
        raw_data = vuln_client.get_vulnerabilities(
            size=per_page, 
            from_index=from_index, 
            filters=filters
        )
        
        print(f"🔍 [Vulnerability API] Raw data response keys: {list(raw_data.keys()) if raw_data else 'No response'}")
        
        if 'error' in raw_data:
            print(f"❌ [Vulnerability API] Elasticsearch error: {raw_data['error']}")
            return jsonify({"error": raw_data['error']}), 500
            
        processed_data = vuln_processor.process_vulnerabilities(raw_data)
        
        print(f"🔍 [Vulnerability API] Processed data - total valid CVEs: {processed_data['summary']['total_vulnerabilities']}")
        print(f"🔍 [Vulnerability API] Debug info: {processed_data['debug_info']}")
        
        response_data = {
            'vulnerabilities': processed_data['vulnerabilities'],
            'summary': processed_data['summary'],
            'charts': processed_data['charts'],
            'critical_high_vulnerabilities': processed_data['critical_high_vulnerabilities'],
            'pagination': {
                'page': page,
                'per_page': per_page,
                'total': processed_data['summary']['total_vulnerabilities'],
                'pages': (processed_data['summary']['total_vulnerabilities'] + per_page - 1) // per_page
            },
            'last_updated': processed_data['last_updated'],
            'debug_info': processed_data['debug_info']
        }
        
        print(f"✅ [Vulnerability API] Sending response with {len(processed_data['vulnerabilities'])} valid CVEs")
        return jsonify(response_data)
        
    except Exception as e:
        print(f"❌ [Vulnerability API] Exception in /api/vulnerabilities: {str(e)}")
        import traceback
        print(f"❌ [Vulnerability API] Traceback: {traceback.format_exc()}")
        return jsonify({"error": str(e)}), 500

@vuln_bp.route('/api/vulnerabilities/summary')
def get_vulnerability_summary():
    """Get vulnerability summary for dashboard metrics - only valid CVEs"""
    try:
        print("🔍 [Vulnerability Summary] Getting vulnerability summary")
        
        # Get a larger sample of data for accurate statistics
        raw_data = vuln_client.get_all_vulnerabilities_for_stats(size=10000)
        
        if 'error' in raw_data:
            return jsonify({"error": raw_data['error']}), 500
            
        # Process the data to get accurate counts
        processed_data = vuln_processor.process_vulnerabilities(raw_data)
        
        print(f"🔍 [Vulnerability Summary] Processed {processed_data['debug_info']['valid_cves']} valid CVEs")
        print(f"🔍 [Vulnerability Summary] Severity breakdown: {processed_data['debug_info']['severity_breakdown']}")
        
        return jsonify({
            'summary': processed_data['summary'],
            'charts': processed_data['charts']
        })
        
    except Exception as e:
        print(f"❌ [Vulnerability Summary] Error: {str(e)}")
        return jsonify({"error": str(e)}), 500

@vuln_bp.route('/api/vulnerabilities/debug')
def debug_vulnerabilities():
    """Debug endpoint to check vulnerability data"""
    try:
        print("🔍 [Vulnerability Debug] Testing vulnerability data")
        
        # Test basic CVE query
        test_data = vuln_client.get_vulnerabilities(size=10)
        
        # Get stats for debugging
        stats_data = vuln_client.get_vulnerability_stats()
        
        # Check indices
        index_check = vuln_client._make_request("_cat/indices/wazuh-states-vulnerabilities-*", {})
        
        debug_info = {
            "elasticsearch_connection": "success" if 'error' not in test_data else "failed",
            "vulnerability_index_exists": "success" if 'error' not in index_check else "failed",
            "total_hits": test_data.get('hits', {}).get('total', {}).get('value', 0) if 'error' not in test_data else 0,
            "aggregation_stats": stats_data.get('aggregations', {}) if 'error' not in stats_data else {},
            "sample_vulnerabilities": [],
            "invalid_entries": []
        }
        
        if debug_info['total_hits'] > 0:
            for hit in test_data.get('hits', {}).get('hits', []):
                source = hit.get('_source', {})
                vulnerability = source.get('vulnerability', {})
                cve_id = vulnerability.get('id', '')
                
                if VulnerabilityDataProcessor.is_valid_cve(cve_id):
                    debug_info["sample_vulnerabilities"].append({
                        "cve_id": cve_id,
                        "severity": vulnerability.get('severity'),
                        "normalized_severity": VulnerabilityDataProcessor.normalize_severity(vulnerability.get('severity', '')),
                        "package": source.get('package', {}).get('name'),
                        "agent": source.get('agent', {}).get('name')
                    })
                else:
                    debug_info["invalid_entries"].append({
                        "cve_id": cve_id,
                        "severity": vulnerability.get('severity'),
                        "reason": "Invalid CVE format" if cve_id else "Missing CVE ID"
                    })
                
                # Only show first 5 of each
                if len(debug_info["sample_vulnerabilities"]) >= 5 and len(debug_info["invalid_entries"]) >= 5:
                    break
        
        return jsonify(debug_info)
        
    except Exception as e:
        return jsonify({"error": str(e)}), 500

@vuln_bp.route('/api/vulnerabilities/agents')
def get_agents_list():
    """Get list of agents with vulnerabilities - only valid CVEs"""
    try:
        # Get some data to extract agents
        raw_data = vuln_client.get_vulnerabilities(size=100)
        processed_data = vuln_processor.process_vulnerabilities(raw_data)
        
        agents = set()
        for vuln in processed_data['vulnerabilities']:
            if vuln['agent_name'] and vuln['agent_name'] != 'Unknown Agent':
                agents.add(vuln['agent_name'])
        
        return jsonify({
            'agents': sorted(list(agents))
        })
    except Exception as e:
        print(f"❌ [Vulnerability Agents] Error: {str(e)}")
        return jsonify({"error": str(e)}), 500

@vuln_bp.route('/api/vulnerabilities/export')
def export_vulnerabilities():
    """Export vulnerabilities to CSV format - only valid CVEs"""
    try:
        raw_data = vuln_client.get_vulnerabilities(size=5000)
        processed_data = vuln_processor.process_vulnerabilities(raw_data)
        
        # Convert to CSV format
        csv_data = "CVE ID,Severity,Title,Agent,Package,Version,CVSS Score,Detected At\n"
        
        for vuln in processed_data['vulnerabilities']:
            csv_data += f"\"{vuln['cve_id']}\",\"{vuln['severity']}\",\"{vuln['title']}\",\"{vuln['agent_name']}\",\"{vuln['package_name']}\",\"{vuln['package_version']}\",\"{vuln['cvss_score']}\",\"{vuln['detected_at']}\"\n"
        
        return csv_data, 200, {
            'Content-Type': 'text/csv',
            'Content-Disposition': 'attachment; filename=valid_cve_vulnerabilities_export.csv'
        }
        
    except Exception as e:
        print(f"❌ [Vulnerability Export] Error: {str(e)}")
        return jsonify({"error": str(e)}), 500

@vuln_bp.route('/api/vulnerabilities/<vulnerability_id>')
def get_vulnerability_detail(vulnerability_id):
    """Get detailed information for a specific vulnerability"""
    try:
        query = {
            "query": {
                "term": {
                    "_id": vulnerability_id
                }
            }
        }
        
        raw_data = vuln_client.get_vulnerabilities(query=query)
        
        if raw_data['hits']['hits']:
            vuln_data = vuln_processor.process_single_vulnerability(raw_data['hits']['hits'][0])
            if vuln_data:
                return jsonify(vuln_data)
            else:
                return jsonify({"error": "Failed to process vulnerability data"}), 500
        else:
            return jsonify({"error": "Vulnerability not found"}), 404
            
    except Exception as e:
        print(f"❌ [Vulnerability Detail] Error: {str(e)}")
        return jsonify({"error": str(e)}), 500
